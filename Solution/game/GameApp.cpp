// ======================================================================================
// File         : GameApp.cpp
// Author       : Wu Jie 
// Last Change  : 10/12/2010 | 11:44:00 AM | Tuesday,October
// Description  : 
// ======================================================================================

///////////////////////////////////////////////////////////////////////////////
// includes
///////////////////////////////////////////////////////////////////////////////

#include "game_pch.h"

// Headers for the various system services we use:
#include <efd/ServiceAllocator.h>
#include <egf/ServiceAllocator.h>
#include <ecr/ServiceAllocator.h>

#if defined(EE_PLATFORM_WIN32)
#include <efd/Win32/Win32PlatformService.h>
#elif defined(EE_PLATFORM_PS3)
#include <efd/PS3/PS3PlatformService.h>
#endif

#include <egmAnimation/AnimationService.h>

// Our main application service:
#include "GameApp.h"

#include "AIService.h"
#include "InGameCameraService.h"

// Other various headers
#include <efd/SystemUniqueIndex.h>
#include <efd/FileDestination.h>
#include <efd/ConfigManager.h>
#include <egf/EntityLoaderService.h>
#include <egf/FlatModelManager.h>
#include <egf/EntityManager.h>
#include <efd/AssetFactoryManager.h>
#include <egf/StandardModelLibraryFlatModelIDs.h>
#include <ecr/CameraService.h>
#include <ecrInput/InputService.h>
#include <egfLua/SchedulerLua.h>

//这个用来创建快速迭代的服务的头函数，现在先用来为模拟调试所用
#include <egf/RapidIterationService.h>


//地形的头文件
#include <NiTerrainLib.h>
#include <NiParticle.h>
//添加移动使用的MovementService
#include "MovementService.h"

//添加Physx 地形服务#include <egmPhysXTerrain\PhysXTerrainService.h>//添加白盒服务#include <egmPhysXWhitebox\PhysXWhiteboxService.h>#include "GameControlService.h"
#include "GameStateService.h"
#include "GameInitingState.h"
#include "GameLoadingState.h"
#include "GamePlayingState.h"
#include "GameWorldService.h"
#include "net/NetWorkService.h"

#include <Ni2DStringRenderClick.h>
#include <egmTerrain\TerrainService.h>

//添加PhysxCharacterMovementService 服务
#include "PhysxCharacterMovementService.h"

#include "GameControlService.h"

#include <egmPhysXWhitebox\PhysXWhiteboxService.h>

#include <egmPhysXTerrain\PhysXTerrainService.h>



//------------------------------------------------------------------------------------------------
using namespace efd;
using namespace egf;
using namespace ecr;

//------------------------------------------------------------------------------------------------
#if !defined(EE_DYNAMIC_BEHAVIOR_LOAD)
// This include is only necessary when static Lua game packs are being linked in.

// Since we statically link game-pack built-ins we need to know about all these methods.  These
// functions are typically auto-generated by SWIG.
extern "C" int luaopen_ecr(lua_State *L);
extern "C" int luaopen_egmAnimation(lua_State *L);
extern "C" int luaopen_CameraAPI(lua_State *L);
extern "C" int luaopen_MovementAPI(lua_State *L);
//声明Physx lua 接口
extern "C" int luaopen_bapiPhysXBase(lua_State *L);
//声明PhysxCharacterMovementAPI lua 接口
extern "C" int luaopen_PhysxCharacterMovementAPI(lua_State *L);



#include <NiLicense.h>
NiEmbedGamebryoLicenseCode;

#endif // !defined(EE_DYNAMIC_BEHAVIOR_LOAD)

//------------------------------------------------------------------------------------------------
static const char g_AppName[] = "GameApp";
static efd::SystemUniqueIndex g_uniqueIndex("GameApp");

//------------------------------------------------------------------------------------------------
EE_IMPLEMENT_CONCRETE_CLASS_INFO(GameApp);

EE_HANDLER_WRAP(GameApp, HandleCameraDiscoverMessage, EntityChangeMessage,
				kMSGID_OwnedEntityAdded);
//EE_HANDLER(GameApp, HandleActionMessage, ecrInput::InputActionMessage);

//------------------------------------------------------------------------------------------------
GameApp::GameApp()
{
	// The ServiceManager is the heart of any Foundation based application.  It owns all
	// of the System Services that compose your application and runs the main loop.
	m_spServiceManager = EE_NEW ServiceManager();
}

//------------------------------------------------------------------------------------------------
GameApp::~GameApp()
{
	m_spServiceManager = NULL;
}

//------------------------------------------------------------------------------------------------
efd::SInt32 GameApp::Go(
						efd::InstanceRef instance,
						efd::InstanceRef previous,
						CmdLineType commandLine,
						int argcInit,
						char** argvInit)
{
	if (SetupServices(instance, previous, commandLine, argcInit, argvInit))
	{
		m_spServiceManager->Run();

		// We need to release the service manager so that it will release all the services that it
		// holds references to (which includes GameApp itself) or else we'll have a circular
		// reference which will prevent proper shutdown from occurring.
		m_spServiceManager = NULL;



		return 0;
	}
	return 1;
}

//------------------------------------------------------------------------------------------------
void GameApp::InitLoggingDestinations()
{
	// The Logger is a special Singleton, not a system service, so it must be created and
	// registered by calling LoggerSingleton::Initialize. This should be created as early as
	// possible to avoid missing any important log messages.
	LoggerPtr spLogger = EE_NEW Logger();
	efd::LoggerSingleton::Initialize(spLogger);

	// You can specify one or more output handlers for each logging module.  In this case we
	// are simply logging everything to a text file, but we could route different modules to
	// different files or all critical errors to a separate file.  We could also log to other
	// destinations like OutputDebugString or a network socket by using specialized
	// ILogDestination implementations.
	utf8string name =  g_uniqueIndex.GetName();
	utf8string strLogFileName(Formatted, "./Log/%s.log", name.c_str());
	FileDestinationPtr logDest = EE_NEW FileDestination("default", strLogFileName,
		FileDestination::kFileOverwrite);
	spLogger->AddDest(logDest, true);

	// Logging defaults to having level 0 to 3 errors and level 0 to 1 non-errors enabled.
	// You can override those defaults here either for all categories or specific categories.
	// See the following examples:
	//  spLogger->SetLogLevel(efd::kALL, efd::ILogger::kLogMask_None);
	//  spLogger->SetLogLevel(efd::kEntity, efd::ILogger::kLogMask_All);
	// Also note that default logging settings can be changed via the config.ini file too, so
	// there is no need to recompile your code to change the log configuration.
}

//------------------------------------------------------------------------------------------------
bool GameApp::SetupServices(
							efd::InstanceRef instance,
							efd::InstanceRef previous,
							CmdLineType commandLine,
							int argcInit,
							char** argvInit)
{
	// Setup the default logging as soon as possible so other services can log early
	InitLoggingDestinations();

	// Set the name displayed by this process when connected to Toolbench
	m_spServiceManager->SetVirtualProcessName("GameApp");

	// Use the Service Allocator helper functions to create common game services needed by
	// most applications.  This is a simplified approach to creating instances of the services
	// directly.

	// Foundation services - messaging, logging, asset service, application configuration
	EE_VERIFY(efd::CreateFoundationServices(m_spServiceManager, argcInit, argvInit));

	// GameApp Framework services - entities, behaviors, rapid iteration
	EE_VERIFY(egf::CreateGameServices(m_spServiceManager));

	// Core Runtime services - rendering, lights, cameras, scenes
	EE_VERIFY(ecr::CreateRuntimeServices(
		m_spServiceManager,
		ecr::rsaf_NO_PICK_SERVICE));




	// The AnimationService handles all actors, which are animating scene objects.
	// A note on priority, we use a higher priority than the scene graph service so the actors
	// get updated before their associated scene graph nodes.
	egmAnimation::AnimationServicePtr spAnimationService = EE_NEW egmAnimation::AnimationService();
	m_spServiceManager->RegisterSystemService(spAnimationService);

#ifndef EE_CONFIG_SHIPPING
	// 创建 Sim Debugger. 他被RapidIterationService 所管。
	RapidIterationSystemServicePtr spRapidIteration = m_spServiceManager->GetSystemServiceAs<
		RapidIterationSystemService>();
	if (spRapidIteration)
		spRapidIteration->CreateSimDebugger();
#endif

	// The InputService service manages input from keyboard and joystick devices.  It uses an
	// actionmap to convert device input into events.  Further you can register for either
	// message based or behavior based callbacks when an input event occurs.
	ecrInput::InputServicePtr spInputService = EE_NEW ecrInput::InputService(false, false);
	m_spServiceManager->RegisterSystemService(spInputService);



	// Since we want to be able to run Lua behaviors we must add the Lua scripting runtime to the
	// scheduler.
	Scheduler* pScheduler = m_spServiceManager->GetSystemServiceAs<Scheduler>();
	pScheduler->RegisterScriptingRuntime("Lua", BehaviorType_Lua, EE_NEW SchedulerLua());

	// Our GameApp application object is also a service that controls some game-specific logic
	m_spServiceManager->RegisterSystemService(this);

	IConfigManagerPtr spConfigManager = m_spServiceManager->GetSystemServiceAs<IConfigManager>();
#if defined(EE_PLATFORM_WIN32)
	// On windows you can use the Win32PlatformService to implement a simple default windows
	// message pump.  It will create a main window and pump messages for it.
	Win32PlatformServicePtr spWin32 = EE_NEW Win32PlatformService(instance, previous, commandLine);
	spWin32->SetWindowTitle(g_uniqueIndex.GetName());
	spWin32->SetWndProc(&MsgProc);

	utf8string width, height;
	UInt32 windowWidth = 1280;
	UInt32 windowHeight = 720;

	if (spConfigManager->FindValue("Game.WindowWidth", width)) {
		if (!width.empty())
			windowWidth = atoi(width.c_str());
	}

	if (spConfigManager->FindValue("Game.WindowHeight", height)) {
		if (!height.empty())
			windowHeight = atoi(height.c_str());
	}

	spWin32->SetWindowWidth(windowWidth);
	spWin32->SetWindowHeight(windowHeight);

	int xSlots = GetSystemMetrics(SM_CXSCREEN) / windowWidth;
	int ySlots = GetSystemMetrics(SM_CYSCREEN) / windowHeight;
	UInt32 left = (windowWidth * ((g_uniqueIndex.GetIndex()-1)%xSlots)) + 1;
	UInt32 top = (windowHeight * (((g_uniqueIndex.GetIndex()-1)/xSlots)%ySlots)) + 1;

	spWin32->SetWindowLeft(left);
	spWin32->SetWindowTop(top);

	spWin32->SetWindowClass(g_AppName);

	m_spServiceManager->RegisterSystemService(spWin32);
#elif defined(EE_PLATFORM_PS3)
	// This service is used to perform any PS3 specific behavior that may be required such
	// as running PS3 specific initialization code.
	const int callbackSlot = 0;
	PS3PlatformServicePtr spPS3 = EE_NEW PS3PlatformService(callbackSlot);

	m_spServiceManager->RegisterSystemService(spPS3);
#endif

#if !defined (EE_DYNAMIC_BEHAVIOR_LOAD)
	// For Statically linked built-ins we need to add the static ecr module to the Lua
	// scheduler here before it starts ticking.  We do this by registering the SWIG-generated
	// init function with the scheduler as a static built-in function.  Static built-ins can be
	// used on any platform, but since DLLs are easy to use on Windows we are using DLLs on that
	// platform.  With DLLs we can specify what modules to load purely through config.ini settings
	// and we can also reload those DLLs on the fly which makes testing changes easier.
	EE_VERIFY(SchedulerLua::AddStaticBuiltinInitFunction(luaopen_ecr));
	EE_VERIFY(SchedulerLua::AddStaticBuiltinInitFunction(luaopen_egmAnimation));
	EE_VERIFY(SchedulerLua::AddStaticBuiltinInitFunction(luaopen_CameraAPI));
	EE_VERIFY(SchedulerLua::AddStaticBuiltinInitFunction(luaopen_MovementAPI));
	EE_VERIFY(SchedulerLua::AddStaticBuiltinInitFunction(luaopen_bapiPhysXBase));
	EE_VERIFY(SchedulerLua::AddStaticBuiltinInitFunction(luaopen_PhysxCharacterMovementAPI));



#endif // !defined (EE_DYNAMIC_BEHAVIOR_LOAD)



	// Some shared code might run slightly different based on whether it is being used in
	// a client application or a tool application.  We call this concept the Program Type,
	// in order for such code to operate correctly you need to tell the ServiceManager what
	// Program Type your application is running as.
	m_spServiceManager->SetProgramType(ServiceManager::kProgType_Client);

	//注册网络
	NetWorkServicePtr pNetWorkService = EE_NEW NetWorkService();
	m_pServiceManager->RegisterSystemService(pNetWorkService);

	// 注册worldService
	GameWorldServicePtr pWorldService = EE_NEW GameWorldService();
	m_pServiceManager->RegisterSystemService(pWorldService);

	// register AI service
	AIServicePtr spAIService = EE_NEW AIService();
	m_spServiceManager->RegisterSystemService(spAIService);

	// register InGameCamera service
	InGameCameraServicePtr spInGameCameraService = EE_NEW InGameCameraService();
	m_spServiceManager->RegisterSystemService(spInGameCameraService);

	// 注册controlService
	GameControlServicePtr pControlService = EE_NEW GameControlService();
	m_pServiceManager->RegisterSystemService(pControlService);

	// PhysX services -  PhysX 模拟 和 碰撞和/triggers
	EE_VERIFY (egfPhysX::CreatePhysXServices(m_spServiceManager));


	egmPhysXWhitebox::PhysXWhiteboxService * pkWhiteboxService = EE_NEW egmPhysXWhitebox::PhysXWhiteboxService();
	m_pServiceManager->RegisterSystemService(pkWhiteboxService);

	ecrPhysX::PropService * pkPropService =  EE_NEW ecrPhysX::PropService();
	m_pServiceManager->RegisterSystemService(pkPropService);


	//注册MovementService
	MovementService * pMovementService = EE_NEW MovementService();
	m_pServiceManager->RegisterSystemService(pMovementService);

	// registe stateService
	GameStateServicePtr pGameStateService = EE_NEW GameStateService();
	m_pServiceManager->RegisterSystemService(pGameStateService);



	// Startup PhysX
	m_pPhysXSDKManager = efdPhysX::PhysXSDKManager::GetManager();
	//构造Physx内存分配器
	m_pPhysXAllocator = EE_NEW efdPhysX::PhysXAllocator();

	if (!m_pPhysXSDKManager->Initialize(m_pPhysXAllocator))
	{
		EE_FAIL("Could not initialize the PhysX SDK.");
		return false;
	}
	m_pPhysXSDKManager->Configure(spConfigManager);


	egmPhysXTerrain::PhysXTerrainService * pkTerrainService = EE_NEW egmPhysXTerrain::PhysXTerrainService();
	m_pServiceManager->RegisterSystemService(pkTerrainService);

	//注册PhysxCharacterMovementService
	PhysxCharacterMovementService * pPhysxCharacterMovementService = EE_NEW PhysxCharacterMovementService(m_pPhysXAllocator);
	m_pServiceManager->RegisterSystemService(pPhysxCharacterMovementService);

	ShowCursor(FALSE);
    return true;
}

//------------------------------------------------------------------------------------------------
efd::SyncResult GameApp::OnPreInit(efd::IDependencyRegistrar* pDependencyRegistrar)
{
    // The service manager pointer gets set by the ServiceManager itself as soon as we are
    // registered with it. The value will be cleared when we are removed from the manager so
    // we can pretty much always rely on the value being set while we are running.
    EE_ASSERT(m_pServiceManager);

    // We load a block during OnInit so depend on the EntityLoaderService. This dependency causes
    // the EntityLoaderService to be initialed before this service and shutdown after this service
    // so we can always rely on that service being available during our OnInit, OnTick and
    // OnShutdown methods.
    //pDependencyRegistrar->AddDependency<EntityLoaderService>();

    // We also manually set our input actions so we need ecrInput::InputService to be available.
    pDependencyRegistrar->AddDependency<ecrInput::InputService>();

    // For managing subscriptions without bypassing leaked subscription detection it is recommended
    // (but not strictly required) that services using subscriptions depend on the MessageService.
    pDependencyRegistrar->AddDependency<MessageService>();

    RenderService* pRenderService = m_pServiceManager->GetSystemServiceAs<RenderService>();
    if (pRenderService)
    {
        pRenderService->SetDefaultSurfaceBackgroundColor(efd::ColorA(0.0f, 0.0f, 0.15f, 1.0f));
    }

	pDependencyRegistrar->AddDependency<GameWorldService>();

	pDependencyRegistrar->AddDependency<GameStateService>();

    return efd::SyncResult_Success;
}

//------------------------------------------------------------------------------------------------
efd::AsyncResult GameApp::OnInit()
{
    // The service manager pointer gets set by the ServiceManager itself as soon as we are
    // registered with it.  The value will be cleared when we are removed from the manager so
    // we can pretty must always rely on the value being set while we are running.
    EE_ASSERT(m_pServiceManager);

    // Initialize random number generator
    HighPrecisionClock clock;
    TimeType currentTime = clock.GetCurrentTime();
    TimeType* pCurrentTime = &currentTime;
    UInt64* seed64 = reinterpret_cast<UInt64*>(pCurrentTime);
    Srand((UInt32)*seed64);

    // If there is no surface, add one.
    RenderServicePtr spRenderService = m_pServiceManager->GetSystemServiceAs<RenderService>();
    if (!spRenderService->GetActiveRenderSurface())
    {
        RenderContext* pRenderContext = EE_NEW RenderContext(spRenderService);
        spRenderService->AddRenderContext(pRenderContext);
        pRenderContext->SetBackgroundColor(NiColorA(0.0f, 0.0f, 0.15f, 1.0f));
        RenderSurfacePtr spSurface = spRenderService->CreateRenderSurface(NULL);
        pRenderContext->AddRenderSurface(spSurface);
        spRenderService->SetActiveRenderSurface(spSurface);

        EE_ASSERT(spRenderService->GetActiveRenderSurface());
    }

   // SetupInputActions();

    // Subscribe to the local message category to receive entity discovery messages. Such a message
    // will be generated when our camera is created, and we use this to associate the camera with
    // the render surface later.
    MessageService* pMessageService = m_pServiceManager->GetSystemServiceAs<MessageService>();
    EE_ASSERT(pMessageService);
    pMessageService->Subscribe(this, kCAT_LocalMessage);

    // Load the main block file
//     efd::IConfigManager* pConfig = m_pServiceManager->GetSystemServiceAs<efd::IConfigManager>();
//     efd::utf8string world_file = pConfig->FindValue("Game.InitialWorld");
//     if (world_file.empty())
//     {
//         EE_LOG(efd::kApp, efd::ILogger::kERR0, ("No block file specified, set Game.InitialWorld."));
//     }
//     else
//     {
// //         EntityLoaderService* els = m_pServiceManager->GetSystemServiceAs<EntityLoaderService>();
// // 		EE_ASSERT(els);
// //         els->RequestEntitySetLoad(world_file);
// 		GameWorldService* pWorldSerivce = m_pServiceManager->GetSystemServiceAs<GameWorldService>();
// 		EE_ASSERT(pWorldSerivce);
// 		if (pWorldSerivce)
// 		{
// 			pWorldSerivce->LoadBlock(world_file, true);
// 		}
//     }

// 	// 加入测试文字
// 	Ni2DStringRenderClickPtr pStringRenderClick = NiNew Ni2DStringRenderClick;
// 	RenderSurface* pRenderSuface = spRenderService->GetActiveRenderSurface();
// 	NiDefaultClickRenderStep* pClickRenderStep = NiDynamicCast(NiDefaultClickRenderStep, pRenderSuface->GetRenderStep());
// 	EE_ASSERT(pClickRenderStep);
// 	pClickRenderStep->AppendRenderClick(pStringRenderClick);
// 
// 	//NiFontPtr spFont = NiFont::Create(spRenderService->GetRenderer(), "ArialUnicodeMS_BA_36.nff");
// 	//NIASSERT(spFont);
// 
// 	NiColorA kRed(1.0f, 0.0f, 0.0f, 1.0f);
// 	Ni2DStringPtr spTestString = NiNew Ni2DString(spFont,
// 		NiFontString::COLORED | NiFontString::CENTERED,
// 		32, "Test String\nTwo Lines", kRed, 320, 240);
// 
// 
// 	pStringRenderClick->Append2DString(spTestString);


	SetupGameStates();

    return efd::AsyncResult_Complete;
}

//------------------------------------------------------------------------------------------------
efd::AsyncResult GameApp::OnTick()
{

    return AsyncResult_Complete;
}

//------------------------------------------------------------------------------------------------
efd::AsyncResult GameApp::OnShutdown()
{

	NiTerrainPhysXUtils::SDM_Shutdown();
	efdPhysX::PhysXSDKManager* pPhysXSDKManager;
	pPhysXSDKManager = efdPhysX::PhysXSDKManager::GetManager();
	if (pPhysXSDKManager)
	{
		pPhysXSDKManager->Shutdown();
	}
	EE_DELETE m_pPhysXAllocator;
	m_pPhysXAllocator = NULL;

    return AsyncResult_Complete;
}

//-----------------------------------------------------------------------------------------------
void GameApp::HandleCameraDiscoverMessage(
    const egf::EntityChangeMessage* pMessage,
    efd::Category targetCategory)
{
    Entity* pEntity = pMessage->GetEntity();
    EE_ASSERT(pEntity);

    // Ignore entities that do not contain a camera entity.
    if (!pEntity->GetModel()->ContainsModel(kFlatModelID_StandardModelLibrary_Camera))
        return;

    RenderService* pRenderService = m_pServiceManager->GetSystemServiceAs<RenderService>();
    EE_ASSERT(pRenderService);
    CameraService* pCameraService = m_pServiceManager->GetSystemServiceAs<CameraService>();
    EE_ASSERT(pCameraService);

    pCameraService->CreateCamera(pEntity->GetEntityID(),
        pRenderService->GetActiveRenderSurface()->GetRenderTargetGroup());

    pCameraService->SetActiveCamera(pEntity->GetEntityID(),
        pRenderService->GetActiveRenderSurface()->GetWindowRef());
}

void GameApp::SetupGameStates()
{
	GameStateService* pGameStateService = m_pServiceManager->GetSystemServiceAs<GameStateService>();
	EE_ASSERT(pGameStateService);
	pGameStateService->AddState(EE_NEW GameInitingState(pGameStateService, GameState::LoadingStateID, "gamebryoLogo.dds"));
	pGameStateService->AddState(EE_NEW GameLoadingState(pGameStateService, GameState::PlayingStateID));
	pGameStateService->AddState(EE_NEW GamePlayingState(pGameStateService));

	efd::IConfigManager* pConfig = m_pServiceManager->GetSystemServiceAs<efd::IConfigManager>();
	efd::utf8string world_file = pConfig->FindValue("Game.InitialWorld");
	if (world_file.empty())
	{
		EE_LOG(efd::kApp, efd::ILogger::kERR0, ("No block file specified, set Game.InitialWorld."));
		return;
	}
	GameState* pGameState = pGameStateService->FindState(GameState::LoadingStateID);
	EE_ASSERT(pGameState);
	GameLoadingState* pLoadingState = EE_DYNAMIC_CAST(GameLoadingState, pGameState);
	EE_ASSERT(pLoadingState);
	pLoadingState->QueueBlockFile(world_file, true);

	pGameStateService->ChangeState(GameState::InitGameStateID);
}

// modify by zyz 2010-11-9 控制权交由GameControlService
//-----------------------------------------------------------------------------------------------
// void GameApp::HandleActionMessage(const ecrInput::InputActionMessage* pMessage,
//     efd::Category targetCategory)
// {
//     if (pMessage->GetEventName() == "GAME_QUIT")
//     {
//         m_pServiceManager->Shutdown();
//     }
// }
// 
// //-----------------------------------------------------------------------------------------------
// void GameApp::SetupInputActions()
// {
//     ecrInput::InputService* pInputService = m_pServiceManager->
//         GetSystemServiceAs<ecrInput::InputService>();
//     EE_ASSERT(pInputService);
//     MessageService* pMessageService = m_pServiceManager->
//         GetSystemServiceAs<MessageService>();
//     EE_ASSERT(pMessageService);
// 
//     // activate our action map
//     EE_VERIFY(pInputService->LoadAllActionMaps("urn:AnimTestActionMap"));
//     pInputService->PushActionMap("Control");
// 
//     // create and subscribe to a category for quit messages
//     m_catQuitGame = pMessageService->GetGloballyUniqueCategory();
//     pInputService->ListenForInputActionEvent("GAME_QUIT", m_catQuitGame);
//     pMessageService->Subscribe(this, m_catQuitGame);
// }
// end modify zyz

//-----------------------------------------------------------------------------------------------
const char* GameApp::GetDisplayName() const
{
    return "GameApp";
}

//-----------------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------------

static const UINT EE_APP_ACTIVATE = WM_USER + 1000;
static const UINT EE_APP_DEACTIVATE = WM_USER + 1001;

LRESULT CALLBACK GameApp::MsgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
	case WM_CHAR:
		{
 			switch ((unsigned char)wParam)
 			{
 			case VK_ESCAPE:
 				PostMessage(hWnd, WM_DESTROY, 0, 0);
 				break;
 			}
		}
		break;

	case WM_ACTIVATEAPP:
		{
			// Activation and deactivation events can be used to reduce CPU usage when the game does
			// not have focus.
			if (wParam == TRUE)
				PostMessage(hWnd, EE_APP_ACTIVATE, 0, 0);
			else
				PostMessage(hWnd, EE_APP_DEACTIVATE, 0, 0);
		}
		break;

	case WM_DESTROY:
		PostQuitMessage(0);
		break;

	//case WM_IME_NOTIFY:// 处理了这个消息 输入法返回的可选文字就不会在显示在输入法窗口 即可实现自己的输入法窗口 比如全屏游戏使用
 // 		{
 // 			switch(wParam)
 // 			{
 // 			case IMN_OPENCANDIDATE:// 打开可选文字框 有生成对应的可选文字列表 就到这里了
 //				{
	//				int a = 0;
 //				}
 //				break;
 // 			case IMN_CHANGECANDIDATE:// 有文字可以选择 在其中获取可选文字列表
 // 				{
 // 					HKL hKL = ::GetKeyboardLayout(0); // 获取当前线程所使用的键盘布局
 // 
 // 					if (hKL && ::ImmIsIME(hKL))
 // 					{
 // 						HIMC hIMC;
 // 						hIMC = ImmGetContext(hWnd); 
 // 						DWORD dwCount = 0, dwSize = 0;
 // 						dwSize = ImmGetCandidateListCount(hIMC, &dwCount);
 // 						if (dwCount > 0)
 // 						{
 // 							efd::wstring wstrCaption;
 // 							char* pBuf   =   new   char[dwSize];   
 // 							LPCANDIDATELIST pList   =   (LPCANDIDATELIST)pBuf;   
 // 
 // 							for   (int i=0;   i<dwCount;   i++)   
 // 							{   
 // 								::ImmGetCandidateList(hIMC,   i,   pList,dwSize);   
 // 								for   (int j=0;   j<pList->dwPageSize;   j++)   
 // 								{
 // 									char* pStr   =   (char*)(pBuf+pList->dwOffset[pList->dwPageStart+j]);
 // 									wchar_t wszStr[MAX_PATH + 1] = {0,};
 // 									MultiByteToWideChar(CP_ACP,0,pStr,-1, wszStr , MAX_PATH);
 // 									wstrCaption = wstrCaption + wszStr + L" ";
 // 								}
 // 							}
 // 
 // 							delete[]   pBuf;   
 //							
 // 						}
 // 
 // 						::ImmReleaseContext(hWnd,hIMC);   
 // 					}
 // 				}
 // 				break;
 // 			}
 // 		}
 // 		break;
 //	case WM_IME_STARTCOMPOSITION:// 打开一个文字输入框 输入了一个字符 就到这里了
 //		{
	//		int  a = 0;
 //		}
 //		break;
 // 	case WM_IME_COMPOSITION: // 具体的文字输入
 // 		{
 // 			HKL hKL = ::GetKeyboardLayout(0); // 获取当前线程所使用的键盘布局
 // 
 // 			if( hKL && ::ImmIsIME(hKL) ) 
 // 			{
 // 				HIMC hIMC = ::ImmGetContext( hWnd );
 // 
 // 				// Get the size of the result string.
 // 				DWORD dwSize = ::ImmGetCompositionString(hIMC, GCS_RESULTSTR, NULL, 0);
 // 
 // 				if (dwSize > 0)
 // 				{
 // 					// increase buffer size for terminating null character, 
 // 					//   maybe it is in UNICOD					dwSize += sizeof(WCHAR);
 // 
 // 					char* lpstr = new char[dwSize];
 // 					memset(lpstr, 0, dwSize);
 // 
 // 					// Get the result strings that is generated by IME into lpstr.
 // 					ImmGetCompositionString(hIMC, GCS_RESULTSTR, lpstr, dwSize);
 // 
 // 					wchar_t* lwszStr = new wchar_t[dwSize];
 // 					memset(lwszStr, 0, dwSize);
 // 					MultiByteToWideChar(CP_ACP,0,lpstr,-1, lwszStr , dwSize);
 // 
 // 					//m_pWindow->setCaption(lwszStr);
 // 
 // 					delete[] lpstr;
 // 					delete[] lwszStr;
 // 				}		
 // 
 // 
 // 				::ImmReleaseContext( hWnd, hIMC );
 // 			}
 // 		}
 // 		break;
	default:
		return DefWindowProc(hWnd, message, wParam, lParam);
	}
	return 0;
}
