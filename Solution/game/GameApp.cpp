// ======================================================================================
// File         : GameApp.cpp
// Author       : Wu Jie 
// Last Change  : 10/12/2010 | 11:44:00 AM | Tuesday,October
// Description  : 
// ======================================================================================

///////////////////////////////////////////////////////////////////////////////
// includes
///////////////////////////////////////////////////////////////////////////////

#include "game_pch.h"

// Headers for the various system services we use:
#include <efd/ServiceAllocator.h>
#include <egf/ServiceAllocator.h>
#include <ecr/ServiceAllocator.h>

#if defined(EE_PLATFORM_WIN32)
#include <efd/Win32/Win32PlatformService.h>
#elif defined(EE_PLATFORM_PS3)
#include <efd/PS3/PS3PlatformService.h>
#endif

#include <egmAnimation/AnimationService.h>

// Our main application service:
#include "GameApp.h"

#include "AIService.h"
#include "InGameCameraService.h"
#include "GameControlService.h"

// Other various headers
#include <efd/SystemUniqueIndex.h>
#include <efd/FileDestination.h>
#include <efd/ConfigManager.h>
#include <egf/EntityLoaderService.h>
#include <egf/FlatModelManager.h>
#include <egf/EntityManager.h>
#include <efd/AssetFactoryManager.h>
#include <egf/StandardModelLibraryFlatModelIDs.h>
#include <ecr/CameraService.h>
#include <ecrInput/InputService.h>
#include <egfLua/SchedulerLua.h>

//这个用来创建快速迭代的服务的头函数，现在先用来为模拟调试所用
#include <egf/RapidIterationService.h>
//这个是physx service 相关头文件
#include <egfPhysX/ServiceAllocator.h> 

//地形的头文件
#include <NiTerrainLib.h>

//添加 Terrain 的相关的头文件，以便于支持Terrain
#include <egmPhysXTerrain/PhysXTerrainService.h>
//添加PhysX 的场景服务
#include <egfPhysX\SceneService.h>
//添加 PhysX 的 道具服务
#include <ecrPhysX\PropService.h>


#include <NiTerrainPhysXUtils.h>  // need to manually initialize SDM
//添加Ragdoll 服务的头文件
#include <egmPhysXRagdoll\RagdollService.h>


#include <NiParticle.h>
#include <NiPhysX.h>
//添加移动使用的MovementService
#include "MovementService.h"

//------------------------------------------------------------------------------------------------
using namespace efd;
using namespace egf;
using namespace ecr;

//------------------------------------------------------------------------------------------------
#if !defined(EE_DYNAMIC_BEHAVIOR_LOAD)
// This include is only necessary when static Lua game packs are being linked in.

// Since we statically link game-pack built-ins we need to know about all these methods.  These
// functions are typically auto-generated by SWIG.
extern "C" int luaopen_ecr(lua_State *L);
extern "C" int luaopen_egmAnimation(lua_State *L);
extern "C" int luaopen_CameraAPI(lua_State *L);
extern "C" int luaopen_MovementAPI(lua_State *L);

//PhysX 的脚本接口
extern "C" int luaopen_bapiPhysXBase(lua_State *L);

#include <NiLicense.h>
NiEmbedGamebryoLicenseCode;

#endif // !defined(EE_DYNAMIC_BEHAVIOR_LOAD)

//------------------------------------------------------------------------------------------------
static const char g_AppName[] = "GameApp";
static efd::SystemUniqueIndex g_uniqueIndex("GameApp");

//------------------------------------------------------------------------------------------------
EE_IMPLEMENT_CONCRETE_CLASS_INFO(GameApp);

EE_HANDLER_WRAP(GameApp, HandleCameraDiscoverMessage, EntityChangeMessage,
                kMSGID_OwnedEntityAdded);
//EE_HANDLER(GameApp, HandleActionMessage, ecrInput::InputActionMessage);

//------------------------------------------------------------------------------------------------
GameApp::GameApp()
{
    // The ServiceManager is the heart of any Foundation based application.  It owns all
    // of the System Services that compose your application and runs the main loop.
    m_spServiceManager = EE_NEW ServiceManager();
}

//------------------------------------------------------------------------------------------------
GameApp::~GameApp()
{
    m_spServiceManager = NULL;
}

//------------------------------------------------------------------------------------------------
efd::SInt32 GameApp::Go(
    efd::InstanceRef instance,
    efd::InstanceRef previous,
    CmdLineType commandLine,
    int argcInit,
    char** argvInit)
{
    if (SetupServices(instance, previous, commandLine, argcInit, argvInit))
    {
        m_spServiceManager->Run();

        // We need to release the service manager so that it will release all the services that it
        // holds references to (which includes GameApp itself) or else we'll have a circular
        // reference which will prevent proper shutdown from occurring.
        m_spServiceManager = NULL;
		NiTerrainPhysXUtils::SDM_Shutdown();
		m_pPhysXSDKManager->Shutdown();
        return 0;
    }
    return 1;
}

//------------------------------------------------------------------------------------------------
void GameApp::InitLoggingDestinations()
{
    // The Logger is a special Singleton, not a system service, so it must be created and
    // registered by calling LoggerSingleton::Initialize. This should be created as early as
    // possible to avoid missing any important log messages.
    LoggerPtr spLogger = EE_NEW Logger();
    efd::LoggerSingleton::Initialize(spLogger);

    // You can specify one or more output handlers for each logging module.  In this case we
    // are simply logging everything to a text file, but we could route different modules to
    // different files or all critical errors to a separate file.  We could also log to other
    // destinations like OutputDebugString or a network socket by using specialized
    // ILogDestination implementations.
    utf8string name =  g_uniqueIndex.GetName();
    utf8string strLogFileName(Formatted, "./Log/%s.log", name.c_str());
    FileDestinationPtr logDest = EE_NEW FileDestination("default", strLogFileName,
        FileDestination::kFileOverwrite);
    spLogger->AddDest(logDest, true);

    // Logging defaults to having level 0 to 3 errors and level 0 to 1 non-errors enabled.
    // You can override those defaults here either for all categories or specific categories.
    // See the following examples:
    //  spLogger->SetLogLevel(efd::kALL, efd::ILogger::kLogMask_None);
    //  spLogger->SetLogLevel(efd::kEntity, efd::ILogger::kLogMask_All);
    // Also note that default logging settings can be changed via the config.ini file too, so
    // there is no need to recompile your code to change the log configuration.
}

//------------------------------------------------------------------------------------------------
bool GameApp::SetupServices(
    efd::InstanceRef instance,
    efd::InstanceRef previous,
    CmdLineType commandLine,
    int argcInit,
    char** argvInit)
{
    // Setup the default logging as soon as possible so other services can log early
    InitLoggingDestinations();

    // Set the name displayed by this process when connected to Toolbench
    m_spServiceManager->SetVirtualProcessName("GameApp");

    // Use the Service Allocator helper functions to create common game services needed by
    // most applications.  This is a simplified approach to creating instances of the services
    // directly.

    // Foundation services - messaging, logging, asset service, application configuration
    EE_VERIFY(efd::CreateFoundationServices(m_spServiceManager, argcInit, argvInit));

    // GameApp Framework services - entities, behaviors, rapid iteration
    EE_VERIFY(egf::CreateGameServices(m_spServiceManager));

    // Core Runtime services - rendering, lights, cameras, scenes
    EE_VERIFY(ecr::CreateRuntimeServices(
        m_spServiceManager,
        ecr::rsaf_NO_PICK_SERVICE));

    // The AnimationService handles all actors, which are animating scene objects.
    // A note on priority, we use a higher priority than the scene graph service so the actors
    // get updated before their associated scene graph nodes.
    egmAnimation::AnimationServicePtr spAnimationService = EE_NEW egmAnimation::AnimationService();
    m_spServiceManager->RegisterSystemService(spAnimationService);

#ifndef EE_CONFIG_SHIPPING
	// 创建 Sim Debugger. 他被RapidIterationService 所管。
	RapidIterationSystemServicePtr spRapidIteration = m_spServiceManager->GetSystemServiceAs<
		RapidIterationSystemService>();
	if (spRapidIteration)
		spRapidIteration->CreateSimDebugger();
#endif

	// The InputService service manages input from keyboard and joystick devices.  It uses an
    // actionmap to convert device input into events.  Further you can register for either
    // message based or behavior based callbacks when an input event occurs.
    ecrInput::InputServicePtr spInputService = EE_NEW ecrInput::InputService(false, false);
    m_spServiceManager->RegisterSystemService(spInputService);

	

    // Since we want to be able to run Lua behaviors we must add the Lua scripting runtime to the
    // scheduler.
    Scheduler* pScheduler = m_spServiceManager->GetSystemServiceAs<Scheduler>();
    pScheduler->RegisterScriptingRuntime("Lua", BehaviorType_Lua, EE_NEW SchedulerLua());

    // Our GameApp application object is also a service that controls some game-specific logic
    m_spServiceManager->RegisterSystemService(this);

    IConfigManagerPtr spConfigManager = m_spServiceManager->GetSystemServiceAs<IConfigManager>();
#if defined(EE_PLATFORM_WIN32)
    // On windows you can use the Win32PlatformService to implement a simple default windows
    // message pump.  It will create a main window and pump messages for it.
    Win32PlatformServicePtr spWin32 = EE_NEW Win32PlatformService(instance, previous, commandLine);
    spWin32->SetWindowTitle(g_uniqueIndex.GetName());

    utf8string width, height;
    UInt32 windowWidth = 1280;
    UInt32 windowHeight = 720;

    if (spConfigManager->FindValue("Game.WindowWidth", width)) {
        if (!width.empty())
            windowWidth = atoi(width.c_str());
    }

    if (spConfigManager->FindValue("Game.WindowHeight", height)) {
        if (!height.empty())
            windowHeight = atoi(height.c_str());
    }

    spWin32->SetWindowWidth(windowWidth);
    spWin32->SetWindowHeight(windowHeight);

    int xSlots = GetSystemMetrics(SM_CXSCREEN) / windowWidth;
    int ySlots = GetSystemMetrics(SM_CYSCREEN) / windowHeight;
    UInt32 left = (windowWidth * ((g_uniqueIndex.GetIndex()-1)%xSlots)) + 1;
    UInt32 top = (windowHeight * (((g_uniqueIndex.GetIndex()-1)/xSlots)%ySlots)) + 1;

    spWin32->SetWindowLeft(left);
    spWin32->SetWindowTop(top);

    spWin32->SetWindowClass(g_AppName);

    m_spServiceManager->RegisterSystemService(spWin32);
#elif defined(EE_PLATFORM_PS3)
    // This service is used to perform any PS3 specific behavior that may be required such
    // as running PS3 specific initialization code.
    const int callbackSlot = 0;
    PS3PlatformServicePtr spPS3 = EE_NEW PS3PlatformService(callbackSlot);

    m_spServiceManager->RegisterSystemService(spPS3);
#endif

#if !defined (EE_DYNAMIC_BEHAVIOR_LOAD)
    // For Statically linked built-ins we need to add the static ecr module to the Lua
    // scheduler here before it starts ticking.  We do this by registering the SWIG-generated
    // init function with the scheduler as a static built-in function.  Static built-ins can be
    // used on any platform, but since DLLs are easy to use on Windows we are using DLLs on that
    // platform.  With DLLs we can specify what modules to load purely through config.ini settings
    // and we can also reload those DLLs on the fly which makes testing changes easier.
    EE_VERIFY(SchedulerLua::AddStaticBuiltinInitFunction(luaopen_ecr));
    EE_VERIFY(SchedulerLua::AddStaticBuiltinInitFunction(luaopen_egmAnimation));
    EE_VERIFY(SchedulerLua::AddStaticBuiltinInitFunction(luaopen_CameraAPI));
	EE_VERIFY(SchedulerLua::AddStaticBuiltinInitFunction(luaopen_MovementAPI));
	//静态链接PhysX lua 接口
	EE_VERIFY(SchedulerLua::AddStaticBuiltinInitFunction(luaopen_bapiPhysXBase));
#endif // !defined (EE_DYNAMIC_BEHAVIOR_LOAD)
	// 启动 PhysX
	m_pPhysXSDKManager = efdPhysX::PhysXSDKManager::GetManager();
	if (!m_pPhysXSDKManager->Initialize())
	{
		EE_FAIL("Could not initialize the PhysX SDK.");
		return false;
	}
	m_pPhysXSDKManager->Configure(spConfigManager);


	// 物理地形的初始化
	NiTerrainPhysXUtils::SDM_Init();

	// PhysX Framework Services
	egfPhysX::SceneServicePtr spSceneService = EE_NEW egfPhysX::SceneService();
	m_spServiceManager->RegisterSystemService(spSceneService);



	// PhysX Runtime Services
	ecrPhysX::PropServicePtr spPropService = EE_NEW ecrPhysX::PropService();
	//spPropService->SetWorkflowManager(spSceneGraphService->GetWorkflowManager());
	m_spServiceManager->RegisterSystemService(spPropService);

	egmPhysXRagdoll::RagdollServicePtr spRagdollService =
		EE_NEW egmPhysXRagdoll::RagdollService();
	m_spServiceManager->RegisterSystemService(spRagdollService);

	egmPhysXTerrain::PhysXTerrainServicePtr spPhysXTerrainService =
		EE_NEW egmPhysXTerrain::PhysXTerrainService();
	m_spServiceManager->RegisterSystemService(spPhysXTerrainService);



    // Some shared code might run slightly different based on whether it is being used in
    // a client application or a tool application.  We call this concept the Program Type,
    // in order for such code to operate correctly you need to tell the ServiceManager what
    // Program Type your application is running as.
    m_spServiceManager->SetProgramType(ServiceManager::kProgType_Client);

    // register AI service
    AIServicePtr spAIService = EE_NEW AIService();
    m_spServiceManager->RegisterSystemService(spAIService);

    // register InGameCamera service
    InGameCameraServicePtr spInGameCameraService = EE_NEW InGameCameraService();
    m_spServiceManager->RegisterSystemService(spInGameCameraService);

	// 注册controlService
	GameControlServicePtr pControlService = EE_NEW GameControlService();
	m_pServiceManager->RegisterSystemService(pControlService);

	//注册MovementService
	MovementService * pMovementService = EE_NEW MovementService();
	m_pServiceManager->RegisterSystemService(pMovementService);



	


    return true;
}

//------------------------------------------------------------------------------------------------
efd::SyncResult GameApp::OnPreInit(efd::IDependencyRegistrar* pDependencyRegistrar)
{
    // The service manager pointer gets set by the ServiceManager itself as soon as we are
    // registered with it. The value will be cleared when we are removed from the manager so
    // we can pretty much always rely on the value being set while we are running.
    EE_ASSERT(m_pServiceManager);

    // We load a block during OnInit so depend on the EntityLoaderService. This dependency causes
    // the EntityLoaderService to be initialed before this service and shutdown after this service
    // so we can always rely on that service being available during our OnInit, OnTick and
    // OnShutdown methods.
    pDependencyRegistrar->AddDependency<EntityLoaderService>();

    // We also manually set our input actions so we need ecrInput::InputService to be available.
    pDependencyRegistrar->AddDependency<ecrInput::InputService>();

    // For managing subscriptions without bypassing leaked subscription detection it is recommended
    // (but not strictly required) that services using subscriptions depend on the MessageService.
    pDependencyRegistrar->AddDependency<MessageService>();

    RenderService* pRenderService = m_pServiceManager->GetSystemServiceAs<RenderService>();
    if (pRenderService)
    {
        pRenderService->SetDefaultSurfaceBackgroundColor(efd::ColorA(0.0f, 0.0f, 0.15f, 1.0f));
    }

    return efd::SyncResult_Success;
}

//------------------------------------------------------------------------------------------------
efd::AsyncResult GameApp::OnInit()
{
    // The service manager pointer gets set by the ServiceManager itself as soon as we are
    // registered with it.  The value will be cleared when we are removed from the manager so
    // we can pretty must always rely on the value being set while we are running.
    EE_ASSERT(m_pServiceManager);

    // Initialize random number generator
    HighPrecisionClock clock;
    TimeType currentTime = clock.GetCurrentTime();
    TimeType* pCurrentTime = &currentTime;
    UInt64* seed64 = reinterpret_cast<UInt64*>(pCurrentTime);
    Srand((UInt32)*seed64);

    // If there is no surface, add one.
    RenderServicePtr spRenderService = m_pServiceManager->GetSystemServiceAs<RenderService>();
    if (!spRenderService->GetActiveRenderSurface())
    {
        RenderContext* pRenderContext = EE_NEW RenderContext(spRenderService);
        spRenderService->AddRenderContext(pRenderContext);
        pRenderContext->SetBackgroundColor(NiColorA(0.0f, 0.0f, 0.15f, 1.0f));
        RenderSurfacePtr spSurface = spRenderService->CreateRenderSurface(NULL);
        pRenderContext->AddRenderSurface(spSurface);
        spRenderService->SetActiveRenderSurface(spSurface);

        EE_ASSERT(spRenderService->GetActiveRenderSurface());
    }

   // SetupInputActions();

    // Subscribe to the local message category to receive entity discovery messages. Such a message
    // will be generated when our camera is created, and we use this to associate the camera with
    // the render surface later.
    MessageService* pMessageService = m_pServiceManager->GetSystemServiceAs<MessageService>();
    EE_ASSERT(pMessageService);
    pMessageService->Subscribe(this, kCAT_LocalMessage);

    // Load the main block file
    efd::IConfigManager* pConfig = m_pServiceManager->GetSystemServiceAs<efd::IConfigManager>();
    efd::utf8string world_file = pConfig->FindValue("Game.InitialWorld");
    if (world_file.empty())
    {
        EE_LOG(efd::kApp, efd::ILogger::kERR0, ("No block file specified, set Game.InitialWorld."));
    }
    else
    {
        EntityLoaderService* els = m_pServiceManager->GetSystemServiceAs<EntityLoaderService>();
		EE_ASSERT(els);
        els->RequestEntitySetLoad(world_file);
    }

    return efd::AsyncResult_Complete;
}

//------------------------------------------------------------------------------------------------
efd::AsyncResult GameApp::OnTick()
{
    return AsyncResult_Complete;
}

//------------------------------------------------------------------------------------------------
efd::AsyncResult GameApp::OnShutdown()
{
    return AsyncResult_Complete;
}

//-----------------------------------------------------------------------------------------------
void GameApp::HandleCameraDiscoverMessage(
    const egf::EntityChangeMessage* pMessage,
    efd::Category targetCategory)
{
    Entity* pEntity = pMessage->GetEntity();
    EE_ASSERT(pEntity);

    // Ignore entities that do not contain a camera entity.
    if (!pEntity->GetModel()->ContainsModel(kFlatModelID_StandardModelLibrary_Camera))
        return;

    RenderService* pRenderService = m_pServiceManager->GetSystemServiceAs<RenderService>();
    EE_ASSERT(pRenderService);
    CameraService* pCameraService = m_pServiceManager->GetSystemServiceAs<CameraService>();
    EE_ASSERT(pCameraService);

    pCameraService->CreateCamera(pEntity->GetEntityID(),
        pRenderService->GetActiveRenderSurface()->GetRenderTargetGroup());

    pCameraService->SetActiveCamera(pEntity->GetEntityID(),
        pRenderService->GetActiveRenderSurface()->GetWindowRef());
}

// modify by zyz 2010-11-9 控制权交由GameControlService
//-----------------------------------------------------------------------------------------------
// void GameApp::HandleActionMessage(const ecrInput::InputActionMessage* pMessage,
//     efd::Category targetCategory)
// {
//     if (pMessage->GetEventName() == "GAME_QUIT")
//     {
//         m_pServiceManager->Shutdown();
//     }
// }
// 
// //-----------------------------------------------------------------------------------------------
// void GameApp::SetupInputActions()
// {
//     ecrInput::InputService* pInputService = m_pServiceManager->
//         GetSystemServiceAs<ecrInput::InputService>();
//     EE_ASSERT(pInputService);
//     MessageService* pMessageService = m_pServiceManager->
//         GetSystemServiceAs<MessageService>();
//     EE_ASSERT(pMessageService);
// 
//     // activate our action map
//     EE_VERIFY(pInputService->LoadAllActionMaps("urn:AnimTestActionMap"));
//     pInputService->PushActionMap("Control");
// 
//     // create and subscribe to a category for quit messages
//     m_catQuitGame = pMessageService->GetGloballyUniqueCategory();
//     pInputService->ListenForInputActionEvent("GAME_QUIT", m_catQuitGame);
//     pMessageService->Subscribe(this, m_catQuitGame);
// }
// end modify zyz

//-----------------------------------------------------------------------------------------------
const char* GameApp::GetDisplayName() const
{
    return "GameApp";
}

//-----------------------------------------------------------------------------------------------

